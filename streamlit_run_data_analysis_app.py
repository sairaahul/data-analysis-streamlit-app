# -*- coding: utf-8 -*-
"""streamlit run data_analysis_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ZQaIyFf63gZ7f3vfARDuMZ5JmcPm3-r
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# Set page configuration
st.set_page_config(
    page_title="Universal Data Analysis App",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
        background: linear-gradient(90deg, #1f77b4, #ff7f0e);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    .metric-container {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 10px;
        border-left: 5px solid #1f77b4;
    }
    .section-header {
        color: #1f77b4;
        font-size: 1.5rem;
        font-weight: bold;
        margin-top: 2rem;
        margin-bottom: 1rem;
    }
    .insight-box {
        background-color: #e8f4f8;
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #1f77b4;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Main title
st.markdown('<h1 class="main-header">üìä Universal Data Analysis App</h1>', unsafe_allow_html=True)
st.markdown('<p style="text-align: center; color: #666; font-size: 1.2rem;">Upload any dataset and get instant visual insights with AI-powered analysis</p>', unsafe_allow_html=True)

# Sidebar for file upload and settings
with st.sidebar:
    st.header("üîß Settings")

    # File upload
    uploaded_file = st.file_uploader(
        "Upload your dataset",
        type=['csv', 'xlsx', 'xls'],
        help="Supported formats: CSV, Excel"
    )

    # Analysis settings
    st.subheader("Analysis Options")
    show_basic_stats = st.checkbox("Basic Statistics", value=True)
    show_correlations = st.checkbox("Correlation Analysis", value=True)
    show_distributions = st.checkbox("Distribution Analysis", value=True)
    show_clustering = st.checkbox("Clustering Analysis", value=False)
    show_time_series = st.checkbox("Time Series Analysis", value=False)

    # Chart customization
    st.subheader("Chart Customization")
    color_palette = st.selectbox(
        "Color Palette",
        ["plotly", "viridis", "plasma", "cividis", "turbo", "rainbow"]
    )
    chart_height = st.slider("Chart Height", 300, 800, 500)

def load_data(file):
    """Load data from uploaded file"""
    try:
        if file.name.endswith('.csv'):
            df = pd.read_csv(file)
        else:
            df = pd.read_excel(file)
        return df
    except Exception as e:
        st.error(f"Error loading file: {str(e)}")
        return None

def detect_column_types(df):
    """Automatically detect column types"""
    numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
    categorical_cols = df.select_dtypes(include=['object']).columns.tolist()
    datetime_cols = []

    # Try to detect datetime columns
    for col in categorical_cols:
        try:
            pd.to_datetime(df[col].dropna().head(100))
            datetime_cols.append(col)
        except:
            pass

    # Remove detected datetime columns from categorical
    categorical_cols = [col for col in categorical_cols if col not in datetime_cols]

    return numeric_cols, categorical_cols, datetime_cols

def create_overview_metrics(df):
    """Create overview metrics cards"""
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin:0; color:#1f77b4;">üìè Rows</h3>
            <h2 style="margin:0;">{df.shape[0]:,}</h2>
        </div>
        """, unsafe_allow_html=True)

    with col2:
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin:0; color:#1f77b4;">üìä Columns</h3>
            <h2 style="margin:0;">{df.shape[1]:,}</h2>
        </div>
        """, unsafe_allow_html=True)

    with col3:
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin:0; color:#1f77b4;">üî¢ Numeric</h3>
            <h2 style="margin:0;">{len(df.select_dtypes(include=[np.number]).columns)}</h2>
        </div>
        """, unsafe_allow_html=True)

    with col4:
        missing_percentage = (df.isnull().sum().sum() / (df.shape[0] * df.shape[1])) * 100
        st.markdown(f"""
        <div class="metric-container">
            <h3 style="margin:0; color:#1f77b4;">‚ùå Missing</h3>
            <h2 style="margin:0;">{missing_percentage:.1f}%</h2>
        </div>
        """, unsafe_allow_html=True)

def create_distribution_plots(df, numeric_cols, categorical_cols):
    """Create distribution plots for numeric and categorical variables"""
    st.markdown('<div class="section-header">üìà Distribution Analysis</div>', unsafe_allow_html=True)

    # Numeric distributions
    if numeric_cols:
        # Multiple histograms
        if len(numeric_cols) > 1:
            rows = (len(numeric_cols) + 2) // 3
            fig = make_subplots(
                rows=rows, cols=3,
                subplot_titles=numeric_cols,
                vertical_spacing=0.1
            )

            for i, col in enumerate(numeric_cols):
                row = i // 3 + 1
                col_pos = i % 3 + 1
                fig.add_trace(
                    go.Histogram(
                        x=df[col],
                        name=col,
                        showlegend=False,
                        marker_color=px.colors.qualitative.Set3[i % len(px.colors.qualitative.Set3)]
                    ),
                    row=row, col=col_pos
                )

            fig.update_layout(
                title="Distribution of Numeric Variables",
                height=chart_height * rows // 2,
                showlegend=False
            )
            st.plotly_chart(fig, use_container_width=True)

        # Box plots for outlier detection
        if len(numeric_cols) > 1:
            fig = go.Figure()
            for col in numeric_cols:
                fig.add_trace(go.Box(
                    y=df[col],
                    name=col,
                    boxmean='sd'
                ))

            fig.update_layout(
                title="Box Plots - Outlier Detection",
                height=chart_height,
                yaxis_title="Values"
            )
            st.plotly_chart(fig, use_container_width=True)

    # Categorical distributions
    if categorical_cols:
        # Top categories for each categorical variable
        for col in categorical_cols[:3]:  # Limit to first 3 categorical columns
            top_categories = df[col].value_counts().head(10)

            col1, col2 = st.columns(2)

            with col1:
                fig = px.bar(
                    x=top_categories.values,
                    y=top_categories.index,
                    orientation='h',
                    title=f"Top Categories in {col}",
                    color=top_categories.values,
                    color_continuous_scale=color_palette
                )
                fig.update_layout(height=chart_height // 2)
                st.plotly_chart(fig, use_container_width=True)

            with col2:
                fig = px.pie(
                    values=top_categories.values,
                    names=top_categories.index,
                    title=f"Distribution of {col}",
                    color_discrete_sequence=px.colors.qualitative.Set3
                )
                fig.update_layout(height=chart_height // 2)
                st.plotly_chart(fig, use_container_width=True)

def create_correlation_analysis(df, numeric_cols):
    """Create correlation analysis"""
    st.markdown('<div class="section-header">üîó Correlation Analysis</div>', unsafe_allow_html=True)

    if len(numeric_cols) > 1:
        # Correlation matrix
        corr_matrix = df[numeric_cols].corr()

        # Interactive heatmap
        fig = px.imshow(
            corr_matrix,
            text_auto=True,
            aspect="auto",
            color_continuous_scale=color_palette,
            title="Correlation Matrix"
        )
        fig.update_layout(height=chart_height)
        st.plotly_chart(fig, use_container_width=True)

        # Scatter plots for highly correlated pairs
        high_corr_pairs = []
        for i in range(len(corr_matrix.columns)):
            for j in range(i+1, len(corr_matrix.columns)):
                corr_val = abs(corr_matrix.iloc[i, j])
                if corr_val > 0.7:  # High correlation threshold
                    high_corr_pairs.append((corr_matrix.columns[i], corr_matrix.columns[j], corr_val))

        if high_corr_pairs:
            st.subheader("High Correlation Pairs (|r| > 0.7)")
            cols = st.columns(min(len(high_corr_pairs), 3))

            for idx, (col1, col2, corr_val) in enumerate(high_corr_pairs[:3]):
                with cols[idx]:
                    fig = px.scatter(
                        df, x=col1, y=col2,
                        title=f"{col1} vs {col2}<br>Correlation: {corr_val:.3f}",
                        color_discrete_sequence=[px.colors.qualitative.Set1[0]]
                    )
                    fig.update_layout(height=chart_height // 2)
                    st.plotly_chart(fig, use_container_width=True)

def create_time_series_analysis(df, datetime_cols, numeric_cols):
    """Create time series analysis"""
    if not datetime_cols or not numeric_cols:
        return

    st.markdown('<div class="section-header">‚è±Ô∏è Time Series Analysis</div>', unsafe_allow_html=True)

    # Convert datetime columns
    datetime_col = datetime_cols[0]
    df[datetime_col] = pd.to_datetime(df[datetime_col])

    # Time series plots
    for num_col in numeric_cols[:3]:  # Limit to first 3 numeric columns
        fig = px.line(
            df.sort_values(datetime_col),
            x=datetime_col,
            y=num_col,
            title=f"{num_col} Over Time",
            color_discrete_sequence=[px.colors.qualitative.Set1[0]]
        )
        fig.update_layout(height=chart_height // 2)
        st.plotly_chart(fig, use_container_width=True)

def create_clustering_analysis(df, numeric_cols):
    """Create clustering analysis"""
    if len(numeric_cols) < 2:
        return

    st.markdown('<div class="section-header">üéØ Clustering Analysis</div>', unsafe_allow_html=True)

    # Conditionally import sklearn to avoid dependency issues
    try:
        from sklearn.preprocessing import StandardScaler
        from sklearn.cluster import KMeans
        from sklearn.decomposition import PCA

        # Prepare data
        X = df[numeric_cols].fillna(df[numeric_cols].mean())
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)

        # Elbow method for optimal clusters
        inertias = []
        K_range = range(1, min(11, len(df)))

        for k in K_range:
            kmeans = KMeans(n_clusters=k, random_state=42)
            kmeans.fit(X_scaled)
            inertias.append(kmeans.inertia_)

        # Plot elbow curve
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=list(K_range),
            y=inertias,
            mode='lines+markers',
            name='Inertia',
            line=dict(color='blue', width=3),
            marker=dict(size=8)
        ))
        fig.update_layout(
            title="Elbow Method for Optimal Number of Clusters",
            xaxis_title="Number of Clusters",
            yaxis_title="Inertia",
            height=chart_height // 2
        )
        st.plotly_chart(fig, use_container_width=True)

        # Perform clustering with optimal number of clusters (simplified to 3)
        optimal_k = 3
        kmeans = KMeans(n_clusters=optimal_k, random_state=42)
        clusters = kmeans.fit_predict(X_scaled)

        # PCA for visualization
        pca = PCA(n_components=2)
        X_pca = pca.fit_transform(X_scaled)

        # Create cluster visualization
        fig = px.scatter(
            x=X_pca[:, 0],
            y=X_pca[:, 1],
            color=clusters,
            title=f"K-Means Clustering (k={optimal_k}) - PCA Projection",
            labels={'x': f'PC1 ({pca.explained_variance_ratio_[0]:.1%} variance)',
                    'y': f'PC2 ({pca.explained_variance_ratio_[1]:.1%} variance)'},
            color_continuous_scale=color_palette
        )
        fig.update_layout(height=chart_height)
        st.plotly_chart(fig, use_container_width=True)

        # Cluster summary
        df_with_clusters = df.copy()
        df_with_clusters['Cluster'] = clusters
        cluster_summary = df_with_clusters.groupby('Cluster')[numeric_cols].mean()

        st.subheader("Cluster Summary (Mean Values)")
        st.dataframe(cluster_summary, use_container_width=True)

    except ImportError:
        st.warning("Clustering analysis requires scikit-learn. Please install it with 'pip install scikit-learn'.")

def generate_insights(df, numeric_cols, categorical_cols):
    """Generate automated insights"""
    st.markdown('<div class="section-header">üß† Automated Insights</div>', unsafe_allow_html=True)

    insights = []

    # Missing data insights
    missing_data = df.isnull().sum()
    if missing_data.sum() > 0:
        highest_missing = missing_data.idxmax()
        insights.append(f"‚ö†Ô∏è Column '{highest_missing}' has the most missing values ({missing_data[highest_missing]:,} or {missing_data[highest_missing]/len(df)*100:.1f}%)")

    # Outlier insights
    for col in numeric_cols[:3]:
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        outliers = df[(df[col] < Q1 - 1.5*IQR) | (df[col] > Q3 + 1.5*IQR)]
        if len(outliers) > 0:
            insights.append(f"üìä Column '{col}' has {len(outliers)} potential outliers ({len(outliers)/len(df)*100:.1f}% of data)")

    # Correlation insights
    if len(numeric_cols) > 1:
        corr_matrix = df[numeric_cols].corr()
        corr_pairs = []
        for i in range(len(corr_matrix.columns)):
            for j in range(i+1, len(corr_matrix.columns)):
                corr_val = abs(corr_matrix.iloc[i, j])
                if corr_val > 0.7:  # High correlation threshold
                    corr_pairs.append((corr_matrix.columns[i], corr_matrix.columns[j], corr_val))

        if corr_pairs:
            # Sort by correlation value
            corr_pairs.sort(key=lambda x: x[2], reverse=True)
            col1, col2, corr_val = corr_pairs[0]
            insights.append(f"üîó Strong correlation ({corr_val:.3f}) found between '{col1}' and '{col2}'")

    # Categorical insights
    for col in categorical_cols[:2]:
        unique_count = df[col].nunique()
        most_common = df[col].value_counts().index[0] if df[col].value_counts().shape[0] > 0 else "N/A"
        most_common_pct = (df[col] == most_common).sum() / len(df) * 100
        insights.append(f"üìã Column '{col}' has {unique_count} unique values. Most common: '{most_common}' ({most_common_pct:.1f}%)")

    # Display insights
    for insight in insights:
        st.markdown(f'<div class="insight-box">{insight}</div>', unsafe_allow_html=True)

def create_advanced_visualizations(df, numeric_cols, categorical_cols):
    """Create advanced visualizations"""
    st.markdown('<div class="section-header">üé® Advanced Visualizations</div>', unsafe_allow_html=True)

    # Pair plot for numeric variables
    if len(numeric_cols) > 1:
        sample_size = min(1000, len(df))  # Limit sample size for performance
        sampled_df = df.sample(sample_size) if len(df) > sample_size else df

        num_cols_for_pair = min(4, len(numeric_cols))  # Limit to first 4 numeric columns
        fig = px.scatter_matrix(
            sampled_df[numeric_cols[:num_cols_for_pair]],
            title="Pair Plot Matrix",
            color_discrete_sequence=[px.colors.qualitative.Set1[0]]
        )
        fig.update_layout(height=600)
        st.plotly_chart(fig, use_container_width=True)

    # Violin plots
    if len(numeric_cols) > 0 and len(categorical_cols) > 0:
        num_col = numeric_cols[0]
        cat_col = categorical_cols[0]

        # Limit categories for better visualization
        cat_values = df[cat_col].value_counts().head(8).index
        filtered_df = df[df[cat_col].isin(cat_values)]

        fig = px.violin(
            filtered_df,
            y=num_col,
            x=cat_col,
            title=f"Distribution of {num_col} by {cat_col}",
            color=cat_col,
            color_discrete_sequence=px.colors.qualitative.Set3
        )
        fig.update_layout(height=chart_height)
        st.plotly_chart(fig, use_container_width=True)

# Main app logic
if uploaded_file is not None:
    # Load data
    df = load_data(uploaded_file)

    if df is not None:
        # Display basic info
        st.success(f"‚úÖ Data loaded successfully! Shape: {df.shape}")

        # Create overview metrics
        create_overview_metrics(df)

        # Detect column types
        numeric_cols, categorical_cols, datetime_cols = detect_column_types(df)

        # Display column information
        col1, col2, col3 = st.columns(3)
        with col1:
            if numeric_cols:
                st.info(f"**Numeric Columns ({len(numeric_cols)}):**\n" + ", ".join(numeric_cols[:5]))
        with col2:
            if categorical_cols:
                st.info(f"**Categorical Columns ({len(categorical_cols)}):**\n" + ", ".join(categorical_cols[:5]))
        with col3:
            if datetime_cols:
                st.info(f"**DateTime Columns ({len(datetime_cols)}):**\n" + ", ".join(datetime_cols[:5]))

        # Data preview
        st.markdown('<div class="section-header">üëÄ Data Preview</div>', unsafe_allow_html=True)
        st.dataframe(df.head(10), use_container_width=True)

        # Generate insights
        generate_insights(df, numeric_cols, categorical_cols)

        # Basic statistics
        if show_basic_stats and numeric_cols:
            st.markdown('<div class="section-header">üìä Basic Statistics</div>', unsafe_allow_html=True)
            st.dataframe(df[numeric_cols].describe(), use_container_width=True)

        # Distribution analysis
        if show_distributions:
            create_distribution_plots(df, numeric_cols, categorical_cols)

        # Correlation analysis
        if show_correlations and len(numeric_cols) > 1:
            create_correlation_analysis(df, numeric_cols)

        # Time series analysis
        if show_time_series and datetime_cols:
            create_time_series_analysis(df, datetime_cols, numeric_cols)

        # Clustering analysis
        if show_clustering and len(numeric_cols) > 1:
            create_clustering_analysis(df, numeric_cols)

        # Advanced visualizations
        create_advanced_visualizations(df, numeric_cols, categorical_cols)

        # Download processed data option
        st.markdown('<div class="section-header">üíæ Download Options</div>', unsafe_allow_html=True)

        # Create download buttons
        col1, col2 = st.columns(2)

        with col1:
            if st.button("üìä Generate Summary Report"):
                # Create a comprehensive summary
                summary_data = {
                    'Dataset Shape': f"{df.shape[0]} rows √ó {df.shape[1]} columns",
                    'Missing Values': f"{df.isnull().sum().sum()} ({(df.isnull().sum().sum() / (df.shape[0] * df.shape[1]) * 100):.1f}%)",
                    'Numeric Columns': len(numeric_cols),
                    'Categorical Columns': len(categorical_cols),
                    'DateTime Columns': len(datetime_cols)
                }

                st.json(summary_data)

        with col2:
            # Option to download processed data
            if numeric_cols:
                # Create a correlation summary
                corr_summary = df[numeric_cols].corr()
                csv_corr = corr_summary.to_csv()
                st.download_button(
                    label="üìà Download Correlation Matrix",
                    data=csv_corr,
                    file_name="correlation_matrix.csv",
                    mime="text/csv"
                )

else:
    # Welcome screen
    st.markdown("""
    <div style="text-align: center; padding: 3rem;">
        <h2>üëã Welcome to the Universal Data Analysis App!</h2>
        <p style="font-size: 1.1rem; color: #666;">
            Upload any CSV or Excel file to get started with automatic data analysis and beautiful visualizations.
        </p>

        <div style="margin: 2rem 0;">
            <h3>üî• Features</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-top: 1rem;">
                <div style="background-color: #f0f8ff; padding: 1rem; border-radius: 8px;">
                    <h4>üìä Automatic Analysis</h4>
                    <p>Instantly analyze any dataset with automatic detection of data types and patterns.</p>
                </div>
                <div style="background-color: #f0fff0; padding: 1rem; border-radius: 8px;">
                    <h4>üé® Beautiful Charts</h4>
                    <p>Generate publication-ready visualizations with customizable color palettes.</p>
                </div>
                <div style="background-color: #fff8f0; padding: 1rem; border-radius: 8px;">
                    <h4>üß† Smart Insights</h4>
                    <p>Get automated insights about correlations, outliers, and data quality.</p>
                </div>
                <div style="background-color: #f8f0ff; padding: 1rem; border-radius: 8px;">
                    <h4>üéØ Advanced Analytics</h4>
                    <p>Clustering, time series analysis, and statistical summaries included.</p>
                </div>
            </div>
        </div>

        <div style="background-color: #e8f4fd; padding: 1.5rem; border-radius: 10px; margin-top: 2rem;">
            <h4>üöÄ How to Use</h4>
            <ol style="text-align: left; max-width: 500px; margin: 0 auto;">
                <li>Click on "Browse files" in the sidebar</li>
                <li>Upload your CSV or Excel file</li>
                <li>Customize your analysis settings</li>
                <li>Explore the generated insights and visualizations</li>
                <li>Download reports and charts as needed</li>
            </ol>
        </div>
    </div>
    """, unsafe_allow_html=True)

# Footer
st.markdown("""
---
<div style="text-align: center; color: #666; padding: 1rem;">
    Built with ‚ù§Ô∏è using Streamlit, Plotly, and Python
</div>""")