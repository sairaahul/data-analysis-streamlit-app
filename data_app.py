# -*- coding: utf-8 -*-
"""DATA APP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qEOZLEm3xV2ZMxVkJKbCjXfeF6cSi0kB
"""

!pip install -r requirements.txt

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from io import StringIO, BytesIO
import base64
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Set page configuration
st.set_page_config(
    page_title="Universal Data Analysis App",
    page_icon="📊",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        padding: 1rem;
        border-radius: 10px;
        margin-bottom: 2rem;
    }

    .metric-container {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 0.5rem 0;
    }

    .chart-container {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 1rem 0;
    }

    .sidebar .stSelectbox {
        color: #2E86AB;
    }

    .stTabs [data-baseweb="tab-list"] {
        gap: 20px;
    }

    .stTabs [data-baseweb="tab"] {
        height: 50px;
        padding-left: 20px;
        padding-right: 20px;
        background-color: #f0f2f6;
        border-radius: 4px 4px 0px 0px;
    }

    .stTabs [aria-selected="true"] {
        background-color: #667eea;
        color: white;
    }
</style>
""", unsafe_allow_html=True)

class DataAnalyzer:
    def __init__(self, df):
        self.df = df
        self.numeric_columns = df.select_dtypes(include=[np.number]).columns.tolist()
        self.categorical_columns = df.select_dtypes(exclude=[np.number]).columns.tolist()
        self.datetime_columns = []

        # Try to identify datetime columns
        for col in self.categorical_columns:
            if df[col].dtype == 'object':
                try:
                    pd.to_datetime(df[col], infer_datetime_format=True)
                    self.datetime_columns.append(col)
                except:
                    pass

    def data_overview(self):
        """Generate comprehensive data overview"""
        overview = {
            'Dataset Shape': f"{self.df.shape[0]:,} rows × {self.df.shape[1]:,} columns",
            'Numeric Columns': len(self.numeric_columns),
            'Categorical Columns': len(self.categorical_columns),
            'DateTime Columns': len(self.datetime_columns),
            'Memory Usage': f"{self.df.memory_usage(deep=True).sum() / 1024**2:.2f} MB",
            'Missing Values': f"{self.df.isnull().sum().sum():,} ({(self.df.isnull().sum().sum() / (self.df.shape[0] * self.df.shape[1]) * 100):.1f}%)"
        }
        return overview

    def generate_summary_stats(self):
        """Generate summary statistics"""
        if self.numeric_columns:
            return self.df[self.numeric_columns].describe()
        return pd.DataFrame()

    def missing_data_analysis(self):
        """Analyze missing data patterns"""
        missing_data = self.df.isnull().sum()
        missing_data = missing_data[missing_data > 0].sort_values(ascending=False)
        missing_percent = (missing_data / len(self.df)) * 100

        missing_df = pd.DataFrame({
            'Column': missing_data.index,
            'Missing Count': missing_data.values,
            'Missing Percentage': missing_percent.values
        })
        return missing_df

    def correlation_analysis(self):
        """Generate correlation matrix for numeric columns"""
        if len(self.numeric_columns) > 1:
            return self.df[self.numeric_columns].corr()
        return pd.DataFrame()

    def outlier_detection(self):
        """Detect outliers using IQR method"""
        outliers_info = {}
        for col in self.numeric_columns:
            Q1 = self.df[col].quantile(0.25)
            Q3 = self.df[col].quantile(0.75)
            IQR = Q3 - Q1
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR
            outliers = self.df[(self.df[col] < lower_bound) | (self.df[col] > upper_bound)]
            outliers_info[col] = {
                'count': len(outliers),
                'percentage': (len(outliers) / len(self.df)) * 100,
                'lower_bound': lower_bound,
                'upper_bound': upper_bound
            }
        return outliers_info

def create_charts(df, analyzer):
    """Create various types of charts based on data"""
    charts = {}

    # 1. Distribution plots for numeric columns
    if analyzer.numeric_columns:
        for col in analyzer.numeric_columns[:4]:  # Limit to first 4 columns
            fig = px.histogram(df, x=col, nbins=30, marginal="box",
                             title=f"Distribution of {col}",
                             color_discrete_sequence=['#667eea'])
            fig.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                font=dict(family="Arial", size=12),
                title_font_size=16,
                height=400
            )
            charts[f'dist_{col}'] = fig

    # 2. Correlation heatmap
    if len(analyzer.numeric_columns) > 1:
        corr_matrix = analyzer.correlation_analysis()
        fig = px.imshow(corr_matrix,
                       text_auto=True,
                       aspect="auto",
                       color_continuous_scale='RdBu_r',
                       title="Correlation Matrix")
        fig.update_layout(
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            height=500
        )
        charts['correlation'] = fig

    # 3. Box plots for outlier detection
    if analyzer.numeric_columns:
        for col in analyzer.numeric_columns[:3]:
            fig = px.box(df, y=col, title=f"Box Plot - {col} (Outlier Detection)",
                        color_discrete_sequence=['#764ba2'])
            fig.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                height=400
            )
            charts[f'box_{col}'] = fig

    # 4. Category frequency plots
    if analyzer.categorical_columns:
        for col in analyzer.categorical_columns[:3]:
            value_counts = df[col].value_counts().head(20)
            fig = px.bar(x=value_counts.index, y=value_counts.values,
                        title=f"Top 20 Values in {col}",
                        color=value_counts.values,
                        color_continuous_scale='viridis')
            fig.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                xaxis_title=col,
                yaxis_title="Count",
                height=400
            )
            charts[f'freq_{col}'] = fig

    # 5. Scatter plots for relationships
    if len(analyzer.numeric_columns) >= 2:
        for i in range(min(3, len(analyzer.numeric_columns)-1)):
            col1, col2 = analyzer.numeric_columns[i], analyzer.numeric_columns[i+1]
            fig = px.scatter(df, x=col1, y=col2,
                           title=f"Relationship: {col1} vs {col2}",
                           color_discrete_sequence=['#ff7f0e'])
            fig.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                height=400
            )
            charts[f'scatter_{col1}_{col2}'] = fig

    # 6. Time series plots (if datetime columns exist)
    if analyzer.datetime_columns and analyzer.numeric_columns:
        datetime_col = analyzer.datetime_columns[0]
        try:
            df_temp = df.copy()
            df_temp[datetime_col] = pd.to_datetime(df_temp[datetime_col])
            df_temp = df_temp.sort_values(datetime_col)

            for num_col in analyzer.numeric_columns[:2]:
                fig = px.line(df_temp, x=datetime_col, y=num_col,
                            title=f"Time Series: {num_col} over {datetime_col}",
                            color_discrete_sequence=['#2ca02c'])
                fig.update_layout(
                    plot_bgcolor='rgba(0,0,0,0)',
                    paper_bgcolor='rgba(0,0,0,0)',
                    height=400
                )
                charts[f'timeseries_{num_col}'] = fig
        except:
            pass

    return charts

def create_advanced_charts(df, chart_type, x_col, y_col, color_col=None, size_col=None):
    """Create advanced customizable charts"""
    if chart_type == "Scatter Plot":
        fig = px.scatter(df, x=x_col, y=y_col, color=color_col, size=size_col,
                        hover_data=df.columns[:5].tolist(),
                        title=f"Scatter Plot: {x_col} vs {y_col}",
                        color_discrete_sequence=px.colors.qualitative.Set3)

    elif chart_type == "Line Chart":
        fig = px.line(df, x=x_col, y=y_col, color=color_col,
                     title=f"Line Chart: {y_col} over {x_col}",
                     color_discrete_sequence=px.colors.qualitative.Set2)

    elif chart_type == "Bar Chart":
        if color_col:
            agg_df = df.groupby([x_col, color_col])[y_col].mean().reset_index()
            fig = px.bar(agg_df, x=x_col, y=y_col, color=color_col,
                        title=f"Bar Chart: Average {y_col} by {x_col} and {color_col}",
                        color_discrete_sequence=px.colors.qualitative.Pastel)
        else:
            agg_df = df.groupby(x_col)[y_col].mean().reset_index()
            fig = px.bar(agg_df, x=x_col, y=y_col,
                        title=f"Bar Chart: Average {y_col} by {x_col}",
                        color_discrete_sequence=['#1f77b4'])

    elif chart_type == "Box Plot":
        fig = px.box(df, x=x_col, y=y_col, color=color_col,
                    title=f"Box Plot: {y_col} by {x_col}",
                    color_discrete_sequence=px.colors.qualitative.Dark2)

    elif chart_type == "Violin Plot":
        fig = px.violin(df, x=x_col, y=y_col, color=color_col,
                       title=f"Violin Plot: {y_col} by {x_col}",
                       color_discrete_sequence=px.colors.qualitative.Alphabet)

    elif chart_type == "Heatmap":
        if df[x_col].dtype in ['object', 'category'] and df[y_col].dtype in ['object', 'category']:
            heatmap_data = pd.crosstab(df[x_col], df[y_col])
            fig = px.imshow(heatmap_data,
                           title=f"Heatmap: {x_col} vs {y_col}",
                           color_continuous_scale='Blues')

    fig.update_layout(
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(family="Arial", size=12),
        title_font_size=16,
        height=500,
        margin=dict(l=50, r=50, t=80, b=50)
    )

    return fig

def download_chart_as_html(fig, filename):
    """Create download link for chart as HTML"""
    html_string = fig.to_html(include_plotlyjs='cdn')
    b64 = base64.b64encode(html_string.encode()).decode()
    href = f'<a href="data:text/html;base64,{b64}" download="{filename}.html">Download Chart as HTML</a>'
    return href

# Main App
def main():
    # Header
    st.markdown("""
    <div class="main-header">
        <h1 style="color: white; text-align: center; margin: 0;">
            📊 Universal Data Analysis App
        </h1>
        <p style="color: white; text-align: center; margin: 10px 0 0 0;">
            Upload any dataset and get instant insights with beautiful visualizations
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Sidebar
    st.sidebar.image("https://via.placeholder.com/300x150/667eea/white?text=Data+Analytics",
                    use_column_width=True)
    st.sidebar.title("📁 Data Upload")

    # File upload
    uploaded_file = st.sidebar.file_uploader(
        "Choose a CSV or Excel file",
        type=['csv', 'xlsx', 'xls'],
        help="Upload your dataset to begin analysis"
    )

    if uploaded_file is not None:
        # Load data
        try:
            if uploaded_file.name.endswith('.csv'):
                df = pd.read_csv(uploaded_file)
            else:
                df = pd.read_excel(uploaded_file)

            # Initialize analyzer
            analyzer = DataAnalyzer(df)

            # Display sample data
            st.subheader("📋 Data Preview")
            col1, col2 = st.columns([3, 1])

            with col1:
                st.dataframe(df.head(10), use_container_width=True)

            with col2:
                overview = analyzer.data_overview()
                st.markdown("### 📊 Dataset Overview")
                for key, value in overview.items():
                    st.metric(label=key, value=value)

            # Main analysis tabs
            tab1, tab2, tab3, tab4, tab5 = st.tabs([
                "🔍 Exploratory Analysis",
                "📈 Automatic Charts",
                "🎨 Custom Charts",
                "🔗 Relationships",
                "📊 Statistical Summary"
            ])

            with tab1:
                st.header("🔍 Exploratory Data Analysis")

                col1, col2 = st.columns(2)

                with col1:
                    st.subheader("Missing Data Analysis")
                    missing_df = analyzer.missing_data_analysis()
                    if not missing_df.empty:
                        fig = px.bar(missing_df, x='Column', y='Missing Percentage',
                                   title="Missing Data by Column",
                                   color='Missing Percentage',
                                   color_continuous_scale='Reds')
                        fig.update_layout(height=400)
                        st.plotly_chart(fig, use_container_width=True)
                        st.dataframe(missing_df, use_container_width=True)
                    else:
                        st.success("✅ No missing data found!")

                with col2:
                    st.subheader("Data Types Distribution")
                    dtype_counts = df.dtypes.value_counts()
                    fig = px.pie(values=dtype_counts.values, names=dtype_counts.index,
                               title="Distribution of Data Types",
                               color_discrete_sequence=px.colors.qualitative.Set3)
                    fig.update_layout(height=400)
                    st.plotly_chart(fig, use_container_width=True)

                # Outlier Analysis
                if analyzer.numeric_columns:
                    st.subheader("🎯 Outlier Detection")
                    outliers = analyzer.outlier_detection()

                    outlier_data = []
                    for col, info in outliers.items():
                        outlier_data.append({
                            'Column': col,
                            'Outlier Count': info['count'],
                            'Outlier Percentage': f"{info['percentage']:.2f}%",
                            'Lower Bound': f"{info['lower_bound']:.2f}",
                            'Upper Bound': f"{info['upper_bound']:.2f}"
                        })

                    outlier_df = pd.DataFrame(outlier_data)
                    st.dataframe(outlier_df, use_container_width=True)

            with tab2:
                st.header("📈 Automatic Chart Generation")

                with st.spinner("Generating charts based on your data..."):
                    charts = create_charts(df, analyzer)

                chart_cols = st.columns(2)
                for i, (chart_name, fig) in enumerate(charts.items()):
                    with chart_cols[i % 2]:
                        st.plotly_chart(fig, use_container_width=True)

                        # Download button for each chart
                        download_link = download_chart_as_html(fig, chart_name)
                        st.markdown(download_link, unsafe_allow_html=True)

            with tab3:
                st.header("🎨 Custom Chart Builder")

                col1, col2 = st.columns([1, 3])

                with col1:
                    st.subheader("Chart Configuration")

                    chart_type = st.selectbox(
                        "Choose Chart Type",
                        ["Scatter Plot", "Line Chart", "Bar Chart", "Box Plot", "Violin Plot", "Heatmap"]
                    )

                    x_column = st.selectbox("X-axis", df.columns)
                    y_column = st.selectbox("Y-axis", df.columns)

                    # Optional parameters
                    color_column = st.selectbox("Color by (optional)", [None] + list(df.columns))

                    if chart_type == "Scatter Plot":
                        size_column = st.selectbox("Size by (optional)", [None] + analyzer.numeric_columns)
                    else:
                        size_column = None

                    if st.button("Generate Custom Chart", type="primary"):
                        try:
                            custom_fig = create_advanced_charts(
                                df, chart_type, x_column, y_column, color_column, size_column
                            )
                            st.session_state['custom_chart'] = custom_fig
                        except Exception as e:
                            st.error(f"Error creating chart: {str(e)}")

                with col2:
                    if 'custom_chart' in st.session_state:
                        st.plotly_chart(st.session_state['custom_chart'], use_container_width=True)

                        # Download button
                        download_link = download_chart_as_html(
                            st.session_state['custom_chart'],
                            f"custom_{chart_type.lower().replace(' ', '_')}"
                        )
                        st.markdown(download_link, unsafe_allow_html=True)

            with tab4:
                st.header("🔗 Relationship Analysis")

                if len(analyzer.numeric_columns) > 1:
                    col1, col2 = st.columns(2)

                    with col1:
                        st.subheader("Correlation Matrix")
                        corr_matrix = analyzer.correlation_analysis()
                        fig_corr = px.imshow(corr_matrix,
                                           text_auto=True,
                                           aspect="auto",
                                           color_continuous_scale='RdBu_r',
                                           title="Feature Correlations")
                        fig_corr.update_layout(height=500)
                        st.plotly_chart(fig_corr, use_container_width=True)

                    with col2:
                        st.subheader("Pairwise Relationships")
                        if len(analyzer.numeric_columns) <= 5:
                            # Create scatter matrix for smaller datasets
                            fig_scatter_matrix = px.scatter_matrix(
                                df[analyzer.numeric_columns],
                                title="Scatter Matrix of Numeric Variables"
                            )
                            fig_scatter_matrix.update_layout(height=600)
                            st.plotly_chart(fig_scatter_matrix, use_container_width=True)
                        else:
                            st.info("Too many numeric columns for scatter matrix. Showing correlation heatmap instead.")
                else:
                    st.info("Not enough numeric columns for relationship analysis.")

            with tab5:
                st.header("📊 Statistical Summary")

                col1, col2 = st.columns(2)

                with col1:
                    st.subheader("Descriptive Statistics")
                    if analyzer.numeric_columns:
                        summary_stats = analyzer.generate_summary_stats()
                        st.dataframe(summary_stats, use_container_width=True)
                    else:
                        st.info("No numeric columns found for statistical summary.")

                with col2:
                    st.subheader("Column Information")
                    column_info = pd.DataFrame({
                        'Column': df.columns,
                        'Data Type': df.dtypes,
                        'Non-Null Count': df.count(),
                        'Null Count': df.isnull().sum(),
                        'Unique Values': df.nunique()
                    })
                    st.dataframe(column_info, use_container_width=True)

                # Data quality assessment
                st.subheader("📋 Data Quality Assessment")
                quality_metrics = {
                    'Completeness': f"{((df.count().sum() / (df.shape[0] * df.shape[1])) * 100):.1f}%",
                    'Uniqueness': f"{(df.nunique().sum() / (df.shape[0] * df.shape[1]) * 100):.1f}%",
                    'Consistency': "Manual review required",
                    'Validity': "Depends on business rules"
                }

                cols = st.columns(len(quality_metrics))
                for i, (metric, value) in enumerate(quality_metrics.items()):
                    with cols[i]:
                        st.metric(label=metric, value=value)

        except Exception as e:
            st.error(f"Error loading file: {str(e)}")
            st.info("Please make sure your file is properly formatted and not corrupted.")

    else:
        # Welcome screen
        st.markdown("""
        ## 🚀 Welcome to the Universal Data Analysis App!

        This app automatically analyzes any dataset you upload and generates beautiful, interactive visualizations.

        ### ✨ Features:
        - **Automatic EDA**: Get instant insights about your data
        - **Interactive Charts**: Explore your data with dynamic visualizations
        - **Custom Chart Builder**: Create exactly the chart you need
        - **Statistical Analysis**: Comprehensive statistical summaries
        - **Export Options**: Download charts as HTML files

        ### 📁 Supported Formats:
        - CSV files (`.csv`)
        - Excel files (`.xlsx`, `.xls`)

        ### 🎯 Perfect for:
        - Data Scientists & Analysts
        - Business Intelligence
        - Academic Research
        - Market Research
        - Any data exploration task!

        **👈 Upload your file using the sidebar to get started!**
        """)

        # Sample dataset option
        if st.button("🔍 Try with Sample Dataset"):
            # Create a sample dataset
            np.random.seed(42)
            sample_data = {
                'Date': pd.date_range('2023-01-01', periods=100, freq='D'),
                'Sales': np.random.normal(1000, 200, 100),
                'Region': np.random.choice(['North', 'South', 'East', 'West'], 100),
                'Product': np.random.choice(['A', 'B', 'C'], 100),
                'Temperature': np.random.normal(25, 5, 100),
                'Marketing_Spend': np.random.normal(500, 100, 100)
            }

            # Save sample data to session state
            st.session_state['sample_df'] = pd.DataFrame(sample_data)
            st.success("Sample dataset loaded! Refresh the page to analyze it.")

if __name__ == "__main__":
    main()